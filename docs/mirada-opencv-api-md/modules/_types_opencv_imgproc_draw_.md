[mirada](../README.md) › ["types/opencv/imgproc_draw"](_types_opencv_imgproc_draw_.md)

# External module: "types/opencv/imgproc_draw"


## Index

### Type aliases

* [HersheyFonts](_types_opencv_imgproc_draw_.md#hersheyfonts)
* [LineTypes](_types_opencv_imgproc_draw_.md#linetypes)
* [MarkerTypes](_types_opencv_imgproc_draw_.md#markertypes)

### Variables

* [FILLED](_types_opencv_imgproc_draw_.md#const-filled)
* [FONT_HERSHEY_COMPLEX](_types_opencv_imgproc_draw_.md#const-font_hershey_complex)
* [FONT_HERSHEY_COMPLEX_SMALL](_types_opencv_imgproc_draw_.md#const-font_hershey_complex_small)
* [FONT_HERSHEY_DUPLEX](_types_opencv_imgproc_draw_.md#const-font_hershey_duplex)
* [FONT_HERSHEY_PLAIN](_types_opencv_imgproc_draw_.md#const-font_hershey_plain)
* [FONT_HERSHEY_SCRIPT_COMPLEX](_types_opencv_imgproc_draw_.md#const-font_hershey_script_complex)
* [FONT_HERSHEY_SCRIPT_SIMPLEX](_types_opencv_imgproc_draw_.md#const-font_hershey_script_simplex)
* [FONT_HERSHEY_SIMPLEX](_types_opencv_imgproc_draw_.md#const-font_hershey_simplex)
* [FONT_HERSHEY_TRIPLEX](_types_opencv_imgproc_draw_.md#const-font_hershey_triplex)
* [FONT_ITALIC](_types_opencv_imgproc_draw_.md#const-font_italic)
* [LINE_4](_types_opencv_imgproc_draw_.md#const-line_4)
* [LINE_8](_types_opencv_imgproc_draw_.md#const-line_8)
* [LINE_AA](_types_opencv_imgproc_draw_.md#const-line_aa)
* [MARKER_CROSS](_types_opencv_imgproc_draw_.md#const-marker_cross)
* [MARKER_DIAMOND](_types_opencv_imgproc_draw_.md#const-marker_diamond)
* [MARKER_SQUARE](_types_opencv_imgproc_draw_.md#const-marker_square)
* [MARKER_STAR](_types_opencv_imgproc_draw_.md#const-marker_star)
* [MARKER_TILTED_CROSS](_types_opencv_imgproc_draw_.md#const-marker_tilted_cross)
* [MARKER_TRIANGLE_DOWN](_types_opencv_imgproc_draw_.md#const-marker_triangle_down)
* [MARKER_TRIANGLE_UP](_types_opencv_imgproc_draw_.md#const-marker_triangle_up)

### Functions

* [arrowedLine](_types_opencv_imgproc_draw_.md#arrowedline)
* [circle](_types_opencv_imgproc_draw_.md#circle)
* [clipLine](_types_opencv_imgproc_draw_.md#clipline)
* [drawContours](_types_opencv_imgproc_draw_.md#drawcontours)
* [drawMarker](_types_opencv_imgproc_draw_.md#drawmarker)
* [ellipse](_types_opencv_imgproc_draw_.md#ellipse)
* [ellipse2Poly](_types_opencv_imgproc_draw_.md#ellipse2poly)
* [fillConvexPoly](_types_opencv_imgproc_draw_.md#fillconvexpoly)
* [fillPoly](_types_opencv_imgproc_draw_.md#fillpoly)
* [getFontScaleFromHeight](_types_opencv_imgproc_draw_.md#getfontscalefromheight)
* [getTextSize](_types_opencv_imgproc_draw_.md#gettextsize)
* [line](_types_opencv_imgproc_draw_.md#line)
* [polylines](_types_opencv_imgproc_draw_.md#polylines)
* [putText](_types_opencv_imgproc_draw_.md#puttext)
* [rectangle](_types_opencv_imgproc_draw_.md#rectangle)

## Type aliases

###  HersheyFonts

Ƭ **HersheyFonts**: *any*

*Defined in [types/opencv/imgproc_draw.ts:550](https://github.com/cancerberoSgx/mirada/blob/2aa7cf1/mirada/src/types/opencv/imgproc_draw.ts#L550)*

Only a subset of Hershey fonts  are supported

___

###  LineTypes

Ƭ **LineTypes**: *any*

*Defined in [types/opencv/imgproc_draw.ts:556](https://github.com/cancerberoSgx/mirada/blob/2aa7cf1/mirada/src/types/opencv/imgproc_draw.ts#L556)*

Only a subset of Hershey fonts  are supported

___

###  MarkerTypes

Ƭ **MarkerTypes**: *any*

*Defined in [types/opencv/imgproc_draw.ts:562](https://github.com/cancerberoSgx/mirada/blob/2aa7cf1/mirada/src/types/opencv/imgproc_draw.ts#L562)*

Only a subset of Hershey fonts  are supported

## Variables

### `Const` FILLED

• **FILLED**: *[LineTypes](_types_opencv_imgproc_draw_.md#linetypes)*

*Defined in [types/opencv/imgproc_draw.ts:524](https://github.com/cancerberoSgx/mirada/blob/2aa7cf1/mirada/src/types/opencv/imgproc_draw.ts#L524)*

___

### `Const` FONT_HERSHEY_COMPLEX

• **FONT_HERSHEY_COMPLEX**: *[HersheyFonts](_types_opencv_imgproc_draw_.md#hersheyfonts)*

*Defined in [types/opencv/imgproc_draw.ts:512](https://github.com/cancerberoSgx/mirada/blob/2aa7cf1/mirada/src/types/opencv/imgproc_draw.ts#L512)*

___

### `Const` FONT_HERSHEY_COMPLEX_SMALL

• **FONT_HERSHEY_COMPLEX_SMALL**: *[HersheyFonts](_types_opencv_imgproc_draw_.md#hersheyfonts)*

*Defined in [types/opencv/imgproc_draw.ts:516](https://github.com/cancerberoSgx/mirada/blob/2aa7cf1/mirada/src/types/opencv/imgproc_draw.ts#L516)*

___

### `Const` FONT_HERSHEY_DUPLEX

• **FONT_HERSHEY_DUPLEX**: *[HersheyFonts](_types_opencv_imgproc_draw_.md#hersheyfonts)*

*Defined in [types/opencv/imgproc_draw.ts:510](https://github.com/cancerberoSgx/mirada/blob/2aa7cf1/mirada/src/types/opencv/imgproc_draw.ts#L510)*

___

### `Const` FONT_HERSHEY_PLAIN

• **FONT_HERSHEY_PLAIN**: *[HersheyFonts](_types_opencv_imgproc_draw_.md#hersheyfonts)*

*Defined in [types/opencv/imgproc_draw.ts:508](https://github.com/cancerberoSgx/mirada/blob/2aa7cf1/mirada/src/types/opencv/imgproc_draw.ts#L508)*

___

### `Const` FONT_HERSHEY_SCRIPT_COMPLEX

• **FONT_HERSHEY_SCRIPT_COMPLEX**: *[HersheyFonts](_types_opencv_imgproc_draw_.md#hersheyfonts)*

*Defined in [types/opencv/imgproc_draw.ts:520](https://github.com/cancerberoSgx/mirada/blob/2aa7cf1/mirada/src/types/opencv/imgproc_draw.ts#L520)*

___

### `Const` FONT_HERSHEY_SCRIPT_SIMPLEX

• **FONT_HERSHEY_SCRIPT_SIMPLEX**: *[HersheyFonts](_types_opencv_imgproc_draw_.md#hersheyfonts)*

*Defined in [types/opencv/imgproc_draw.ts:518](https://github.com/cancerberoSgx/mirada/blob/2aa7cf1/mirada/src/types/opencv/imgproc_draw.ts#L518)*

___

### `Const` FONT_HERSHEY_SIMPLEX

• **FONT_HERSHEY_SIMPLEX**: *[HersheyFonts](_types_opencv_imgproc_draw_.md#hersheyfonts)*

*Defined in [types/opencv/imgproc_draw.ts:506](https://github.com/cancerberoSgx/mirada/blob/2aa7cf1/mirada/src/types/opencv/imgproc_draw.ts#L506)*

___

### `Const` FONT_HERSHEY_TRIPLEX

• **FONT_HERSHEY_TRIPLEX**: *[HersheyFonts](_types_opencv_imgproc_draw_.md#hersheyfonts)*

*Defined in [types/opencv/imgproc_draw.ts:514](https://github.com/cancerberoSgx/mirada/blob/2aa7cf1/mirada/src/types/opencv/imgproc_draw.ts#L514)*

___

### `Const` FONT_ITALIC

• **FONT_ITALIC**: *[HersheyFonts](_types_opencv_imgproc_draw_.md#hersheyfonts)*

*Defined in [types/opencv/imgproc_draw.ts:522](https://github.com/cancerberoSgx/mirada/blob/2aa7cf1/mirada/src/types/opencv/imgproc_draw.ts#L522)*

___

### `Const` LINE_4

• **LINE_4**: *[LineTypes](_types_opencv_imgproc_draw_.md#linetypes)*

*Defined in [types/opencv/imgproc_draw.ts:526](https://github.com/cancerberoSgx/mirada/blob/2aa7cf1/mirada/src/types/opencv/imgproc_draw.ts#L526)*

___

### `Const` LINE_8

• **LINE_8**: *[LineTypes](_types_opencv_imgproc_draw_.md#linetypes)*

*Defined in [types/opencv/imgproc_draw.ts:528](https://github.com/cancerberoSgx/mirada/blob/2aa7cf1/mirada/src/types/opencv/imgproc_draw.ts#L528)*

___

### `Const` LINE_AA

• **LINE_AA**: *[LineTypes](_types_opencv_imgproc_draw_.md#linetypes)*

*Defined in [types/opencv/imgproc_draw.ts:530](https://github.com/cancerberoSgx/mirada/blob/2aa7cf1/mirada/src/types/opencv/imgproc_draw.ts#L530)*

___

### `Const` MARKER_CROSS

• **MARKER_CROSS**: *[MarkerTypes](_types_opencv_imgproc_draw_.md#markertypes)*

*Defined in [types/opencv/imgproc_draw.ts:532](https://github.com/cancerberoSgx/mirada/blob/2aa7cf1/mirada/src/types/opencv/imgproc_draw.ts#L532)*

___

### `Const` MARKER_DIAMOND

• **MARKER_DIAMOND**: *[MarkerTypes](_types_opencv_imgproc_draw_.md#markertypes)*

*Defined in [types/opencv/imgproc_draw.ts:538](https://github.com/cancerberoSgx/mirada/blob/2aa7cf1/mirada/src/types/opencv/imgproc_draw.ts#L538)*

___

### `Const` MARKER_SQUARE

• **MARKER_SQUARE**: *[MarkerTypes](_types_opencv_imgproc_draw_.md#markertypes)*

*Defined in [types/opencv/imgproc_draw.ts:540](https://github.com/cancerberoSgx/mirada/blob/2aa7cf1/mirada/src/types/opencv/imgproc_draw.ts#L540)*

___

### `Const` MARKER_STAR

• **MARKER_STAR**: *[MarkerTypes](_types_opencv_imgproc_draw_.md#markertypes)*

*Defined in [types/opencv/imgproc_draw.ts:536](https://github.com/cancerberoSgx/mirada/blob/2aa7cf1/mirada/src/types/opencv/imgproc_draw.ts#L536)*

___

### `Const` MARKER_TILTED_CROSS

• **MARKER_TILTED_CROSS**: *[MarkerTypes](_types_opencv_imgproc_draw_.md#markertypes)*

*Defined in [types/opencv/imgproc_draw.ts:534](https://github.com/cancerberoSgx/mirada/blob/2aa7cf1/mirada/src/types/opencv/imgproc_draw.ts#L534)*

___

### `Const` MARKER_TRIANGLE_DOWN

• **MARKER_TRIANGLE_DOWN**: *[MarkerTypes](_types_opencv_imgproc_draw_.md#markertypes)*

*Defined in [types/opencv/imgproc_draw.ts:544](https://github.com/cancerberoSgx/mirada/blob/2aa7cf1/mirada/src/types/opencv/imgproc_draw.ts#L544)*

___

### `Const` MARKER_TRIANGLE_UP

• **MARKER_TRIANGLE_UP**: *[MarkerTypes](_types_opencv_imgproc_draw_.md#markertypes)*

*Defined in [types/opencv/imgproc_draw.ts:542](https://github.com/cancerberoSgx/mirada/blob/2aa7cf1/mirada/src/types/opencv/imgproc_draw.ts#L542)*

## Functions

###  arrowedLine

▸ **arrowedLine**(`img`: InputOutputArray, `pt1`: [Point](../classes/_types_opencv__hacks_.point.md), `pt2`: [Point](../classes/_types_opencv__hacks_.point.md), `color`: any, `thickness?`: [int](_types_opencv__hacks_.md#int), `line_type?`: [int](_types_opencv__hacks_.md#int), `shift?`: [int](_types_opencv__hacks_.md#int), `tipLength?`: [double](_types_opencv__hacks_.md#double)): *void*

*Defined in [types/opencv/imgproc_draw.ts:37](https://github.com/cancerberoSgx/mirada/blob/2aa7cf1/mirada/src/types/opencv/imgproc_draw.ts#L37)*

The function [cv::arrowedLine] draws an arrow between pt1 and pt2 points in the image. See also
[line].

**Parameters:**

Name | Type | Description |
------ | ------ | ------ |
`img` | InputOutputArray | Image.  |
`pt1` | [Point](../classes/_types_opencv__hacks_.point.md) | The point the arrow starts from.  |
`pt2` | [Point](../classes/_types_opencv__hacks_.point.md) | The point the arrow points to.  |
`color` | any | Line color.  |
`thickness?` | [int](_types_opencv__hacks_.md#int) | Line thickness.  |
`line_type?` | [int](_types_opencv__hacks_.md#int) | Type of the line. See LineTypes  |
`shift?` | [int](_types_opencv__hacks_.md#int) | Number of fractional bits in the point coordinates.  |
`tipLength?` | [double](_types_opencv__hacks_.md#double) | The length of the arrow tip in relation to the arrow length  |

**Returns:** *void*

___

###  circle

▸ **circle**(`img`: InputOutputArray, `center`: [Point](../classes/_types_opencv__hacks_.point.md), `radius`: [int](_types_opencv__hacks_.md#int), `color`: any, `thickness?`: [int](_types_opencv__hacks_.md#int), `lineType?`: [int](_types_opencv__hacks_.md#int), `shift?`: [int](_types_opencv__hacks_.md#int)): *void*

*Defined in [types/opencv/imgproc_draw.ts:57](https://github.com/cancerberoSgx/mirada/blob/2aa7cf1/mirada/src/types/opencv/imgproc_draw.ts#L57)*

The function [cv::circle] draws a simple or filled circle with a given center and radius.

**Parameters:**

Name | Type | Description |
------ | ------ | ------ |
`img` | InputOutputArray | Image where the circle is drawn.  |
`center` | [Point](../classes/_types_opencv__hacks_.point.md) | Center of the circle.  |
`radius` | [int](_types_opencv__hacks_.md#int) | Radius of the circle.  |
`color` | any | Circle color.  |
`thickness?` | [int](_types_opencv__hacks_.md#int) | Thickness of the circle outline, if positive. Negative values, like FILLED, mean that a filled circle is to be drawn.  |
`lineType?` | [int](_types_opencv__hacks_.md#int) | Type of the circle boundary. See LineTypes  |
`shift?` | [int](_types_opencv__hacks_.md#int) | Number of fractional bits in the coordinates of the center and in the radius value.  |

**Returns:** *void*

___

###  clipLine

▸ **clipLine**(`imgSize`: [Size](../classes/_types_opencv__hacks_.size.md), `pt1`: any, `pt2`: any): *[bool](_types_opencv__hacks_.md#bool)*

*Defined in [types/opencv/imgproc_draw.ts:70](https://github.com/cancerberoSgx/mirada/blob/2aa7cf1/mirada/src/types/opencv/imgproc_draw.ts#L70)*

The function [cv::clipLine] calculates a part of the line segment that is entirely within the
specified rectangle. it returns false if the line segment is completely outside the rectangle.
Otherwise, it returns true .

**Parameters:**

Name | Type | Description |
------ | ------ | ------ |
`imgSize` | [Size](../classes/_types_opencv__hacks_.size.md) | Image size. The image rectangle is Rect(0, 0, imgSize.width, imgSize.height) .  |
`pt1` | any | First line point.  |
`pt2` | any | Second line point.  |

**Returns:** *[bool](_types_opencv__hacks_.md#bool)*

▸ **clipLine**(`imgSize`: Size2l, `pt1`: any, `pt2`: any): *[bool](_types_opencv__hacks_.md#bool)*

*Defined in [types/opencv/imgproc_draw.ts:82](https://github.com/cancerberoSgx/mirada/blob/2aa7cf1/mirada/src/types/opencv/imgproc_draw.ts#L82)*

This is an overloaded member function, provided for convenience. It differs from the above function
only in what argument(s) it accepts.

**Parameters:**

Name | Type | Description |
------ | ------ | ------ |
`imgSize` | Size2l | Image size. The image rectangle is Rect(0, 0, imgSize.width, imgSize.height) .  |
`pt1` | any | First line point.  |
`pt2` | any | Second line point.  |

**Returns:** *[bool](_types_opencv__hacks_.md#bool)*

▸ **clipLine**(`imgRect`: [Rect](../classes/_types_opencv__hacks_.rect.md), `pt1`: any, `pt2`: any): *[bool](_types_opencv__hacks_.md#bool)*

*Defined in [types/opencv/imgproc_draw.ts:94](https://github.com/cancerberoSgx/mirada/blob/2aa7cf1/mirada/src/types/opencv/imgproc_draw.ts#L94)*

This is an overloaded member function, provided for convenience. It differs from the above function
only in what argument(s) it accepts.

**Parameters:**

Name | Type | Description |
------ | ------ | ------ |
`imgRect` | [Rect](../classes/_types_opencv__hacks_.rect.md) | Image rectangle.  |
`pt1` | any | First line point.  |
`pt2` | any | Second line point.  |

**Returns:** *[bool](_types_opencv__hacks_.md#bool)*

___

###  drawContours

▸ **drawContours**(`image`: InputOutputArray, `contours`: InputArrayOfArrays, `contourIdx`: [int](_types_opencv__hacks_.md#int), `color`: any, `thickness?`: [int](_types_opencv__hacks_.md#int), `lineType?`: [int](_types_opencv__hacks_.md#int), `hierarchy?`: [InputArray](_types_opencv__hacks_.md#inputarray), `maxLevel?`: [int](_types_opencv__hacks_.md#int), `offset?`: [Point](../classes/_types_opencv__hacks_.point.md)): *void*

*Defined in [types/opencv/imgproc_draw.ts:175](https://github.com/cancerberoSgx/mirada/blob/2aa7cf1/mirada/src/types/opencv/imgproc_draw.ts#L175)*

The function draws contour outlines in the image if `$\\texttt{thickness} \\ge 0$` or fills the area
bounded by the contours if `$\\texttt{thickness}<0$` . The example below shows how to retrieve
connected components from the binary image and label them: :

```cpp
#include "opencv2/imgproc.hpp"
#include "opencv2/highgui.hpp"

using namespace cv;
using namespace std;

int main( int argc, char** argv )
{
    Mat src;
    // the first command-line parameter must be a filename of the binary
    // (black-n-white) image
    if( argc != 2 || !(src=imread(argv[1], 0)).data)
        return -1;

    Mat dst = Mat::zeros(src.rows, src.cols, CV_8UC3);

    src = src > 1;
    namedWindow( "Source", 1 );
    imshow( "Source", src );

    vector<vector<Point> > contours;
    vector<Vec4i> hierarchy;

    findContours( src, contours, hierarchy,
        RETR_CCOMP, CHAIN_APPROX_SIMPLE );

    // iterate through all the top-level contours,
    // draw each connected component with its own random color
    int idx = 0;
    for( ; idx >= 0; idx = hierarchy[idx][0] )
    {
        Scalar color( rand()&255, rand()&255, rand()&255 );
        drawContours( dst, contours, idx, color, FILLED, 8, hierarchy );
    }

    namedWindow( "Components", 1 );
    imshow( "Components", dst );
    waitKey(0);
}
```

When thickness=[FILLED], the function is designed to handle connected components with holes
correctly even when no hierarchy date is provided. This is done by analyzing all the outlines
together using even-odd rule. This may give incorrect results if you have a joint collection of
separately retrieved contours. In order to solve this problem, you need to call [drawContours]
separately for each sub-group of contours, or iterate over the collection using contourIdx
parameter.

**Parameters:**

Name | Type | Description |
------ | ------ | ------ |
`image` | InputOutputArray | Destination image.  |
`contours` | InputArrayOfArrays | All the input contours. Each contour is stored as a point vector.  |
`contourIdx` | [int](_types_opencv__hacks_.md#int) | Parameter indicating a contour to draw. If it is negative, all the contours are drawn.  |
`color` | any | Color of the contours.  |
`thickness?` | [int](_types_opencv__hacks_.md#int) | Thickness of lines the contours are drawn with. If it is negative (for example, thickness=FILLED ), the contour interiors are drawn.  |
`lineType?` | [int](_types_opencv__hacks_.md#int) | Line connectivity. See LineTypes  |
`hierarchy?` | [InputArray](_types_opencv__hacks_.md#inputarray) | Optional information about hierarchy. It is only needed if you want to draw only some of the contours (see maxLevel ).  |
`maxLevel?` | [int](_types_opencv__hacks_.md#int) | Maximal level for drawn contours. If it is 0, only the specified contour is drawn. If it is 1, the function draws the contour(s) and all the nested contours. If it is 2, the function draws the contours, all the nested contours, all the nested-to-nested contours, and so on. This parameter is only taken into account when there is hierarchy available.  |
`offset?` | [Point](../classes/_types_opencv__hacks_.point.md) | Optional contour shift parameter. Shift all the drawn contours by the specified $\texttt{offset}=(dx,dy)$ .  |

**Returns:** *void*

___

###  drawMarker

▸ **drawMarker**(`img`: InputOutputArray, `position`: [Point](../classes/_types_opencv__hacks_.point.md), `color`: any, `markerType?`: [int](_types_opencv__hacks_.md#int), `markerSize?`: [int](_types_opencv__hacks_.md#int), `thickness?`: [int](_types_opencv__hacks_.md#int), `line_type?`: [int](_types_opencv__hacks_.md#int)): *void*

*Defined in [types/opencv/imgproc_draw.ts:195](https://github.com/cancerberoSgx/mirada/blob/2aa7cf1/mirada/src/types/opencv/imgproc_draw.ts#L195)*

The function [cv::drawMarker] draws a marker on a given position in the image. For the moment
several marker types are supported, see [MarkerTypes] for more information.

**Parameters:**

Name | Type | Description |
------ | ------ | ------ |
`img` | InputOutputArray | Image.  |
`position` | [Point](../classes/_types_opencv__hacks_.point.md) | The point where the crosshair is positioned.  |
`color` | any | Line color.  |
`markerType?` | [int](_types_opencv__hacks_.md#int) | The specific type of marker you want to use, see MarkerTypes  |
`markerSize?` | [int](_types_opencv__hacks_.md#int) | The length of the marker axis [default = 20 pixels]  |
`thickness?` | [int](_types_opencv__hacks_.md#int) | Line thickness.  |
`line_type?` | [int](_types_opencv__hacks_.md#int) | Type of the line, See LineTypes  |

**Returns:** *void*

___

###  ellipse

▸ **ellipse**(`img`: InputOutputArray, `center`: [Point](../classes/_types_opencv__hacks_.point.md), `axes`: [Size](../classes/_types_opencv__hacks_.size.md), `angle`: [double](_types_opencv__hacks_.md#double), `startAngle`: [double](_types_opencv__hacks_.md#double), `endAngle`: [double](_types_opencv__hacks_.md#double), `color`: any, `thickness?`: [int](_types_opencv__hacks_.md#int), `lineType?`: [int](_types_opencv__hacks_.md#int), `shift?`: [int](_types_opencv__hacks_.md#int)): *void*

*Defined in [types/opencv/imgproc_draw.ts:228](https://github.com/cancerberoSgx/mirada/blob/2aa7cf1/mirada/src/types/opencv/imgproc_draw.ts#L228)*

The function [cv::ellipse] with more parameters draws an ellipse outline, a filled ellipse, an
elliptic arc, or a filled ellipse sector. The drawing code uses general parametric form. A
piecewise-linear curve is used to approximate the elliptic arc boundary. If you need more control of
the ellipse rendering, you can retrieve the curve using [ellipse2Poly] and then render it with
[polylines] or fill it with [fillPoly]. If you use the first variant of the function and want to
draw the whole ellipse, not an arc, pass `startAngle=0` and `endAngle=360`. If `startAngle` is
greater than `endAngle`, they are swapped. The figure below explains the meaning of the parameters
to draw the blue arc.

**Parameters:**

Name | Type | Description |
------ | ------ | ------ |
`img` | InputOutputArray | Image.  |
`center` | [Point](../classes/_types_opencv__hacks_.point.md) | Center of the ellipse.  |
`axes` | [Size](../classes/_types_opencv__hacks_.size.md) | Half of the size of the ellipse main axes.  |
`angle` | [double](_types_opencv__hacks_.md#double) | Ellipse rotation angle in degrees.  |
`startAngle` | [double](_types_opencv__hacks_.md#double) | Starting angle of the elliptic arc in degrees.  |
`endAngle` | [double](_types_opencv__hacks_.md#double) | Ending angle of the elliptic arc in degrees.  |
`color` | any | Ellipse color.  |
`thickness?` | [int](_types_opencv__hacks_.md#int) | Thickness of the ellipse arc outline, if positive. Otherwise, this indicates that a filled ellipse sector is to be drawn.  |
`lineType?` | [int](_types_opencv__hacks_.md#int) | Type of the ellipse boundary. See LineTypes  |
`shift?` | [int](_types_opencv__hacks_.md#int) | Number of fractional bits in the coordinates of the center and values of axes.  |

**Returns:** *void*

▸ **ellipse**(`img`: InputOutputArray, `box`: any, `color`: any, `thickness?`: [int](_types_opencv__hacks_.md#int), `lineType?`: [int](_types_opencv__hacks_.md#int)): *void*

*Defined in [types/opencv/imgproc_draw.ts:246](https://github.com/cancerberoSgx/mirada/blob/2aa7cf1/mirada/src/types/opencv/imgproc_draw.ts#L246)*

This is an overloaded member function, provided for convenience. It differs from the above function
only in what argument(s) it accepts.

**Parameters:**

Name | Type | Description |
------ | ------ | ------ |
`img` | InputOutputArray | Image.  |
`box` | any | Alternative ellipse representation via RotatedRect. This means that the function draws an ellipse inscribed in the rotated rectangle.  |
`color` | any | Ellipse color.  |
`thickness?` | [int](_types_opencv__hacks_.md#int) | Thickness of the ellipse arc outline, if positive. Otherwise, this indicates that a filled ellipse sector is to be drawn.  |
`lineType?` | [int](_types_opencv__hacks_.md#int) | Type of the ellipse boundary. See LineTypes  |

**Returns:** *void*

___

###  ellipse2Poly

▸ **ellipse2Poly**(`center`: [Point](../classes/_types_opencv__hacks_.point.md), `axes`: [Size](../classes/_types_opencv__hacks_.size.md), `angle`: [int](_types_opencv__hacks_.md#int), `arcStart`: [int](_types_opencv__hacks_.md#int), `arcEnd`: [int](_types_opencv__hacks_.md#int), `delta`: [int](_types_opencv__hacks_.md#int), `pts`: any): *void*

*Defined in [types/opencv/imgproc_draw.ts:266](https://github.com/cancerberoSgx/mirada/blob/2aa7cf1/mirada/src/types/opencv/imgproc_draw.ts#L266)*

The function ellipse2Poly computes the vertices of a polyline that approximates the specified
elliptic arc. It is used by [ellipse]. If `arcStart` is greater than `arcEnd`, they are swapped.

**Parameters:**

Name | Type | Description |
------ | ------ | ------ |
`center` | [Point](../classes/_types_opencv__hacks_.point.md) | Center of the arc.  |
`axes` | [Size](../classes/_types_opencv__hacks_.size.md) | Half of the size of the ellipse main axes. See ellipse for details.  |
`angle` | [int](_types_opencv__hacks_.md#int) | Rotation angle of the ellipse in degrees. See ellipse for details.  |
`arcStart` | [int](_types_opencv__hacks_.md#int) | Starting angle of the elliptic arc in degrees.  |
`arcEnd` | [int](_types_opencv__hacks_.md#int) | Ending angle of the elliptic arc in degrees.  |
`delta` | [int](_types_opencv__hacks_.md#int) | Angle between the subsequent polyline vertices. It defines the approximation accuracy.  |
`pts` | any | Output vector of polyline vertices.  |

**Returns:** *void*

▸ **ellipse2Poly**(`center`: Point2d, `axes`: Size2d, `angle`: [int](_types_opencv__hacks_.md#int), `arcStart`: [int](_types_opencv__hacks_.md#int), `arcEnd`: [int](_types_opencv__hacks_.md#int), `delta`: [int](_types_opencv__hacks_.md#int), `pts`: any): *void*

*Defined in [types/opencv/imgproc_draw.ts:286](https://github.com/cancerberoSgx/mirada/blob/2aa7cf1/mirada/src/types/opencv/imgproc_draw.ts#L286)*

This is an overloaded member function, provided for convenience. It differs from the above function
only in what argument(s) it accepts.

**Parameters:**

Name | Type | Description |
------ | ------ | ------ |
`center` | Point2d | Center of the arc.  |
`axes` | Size2d | Half of the size of the ellipse main axes. See ellipse for details.  |
`angle` | [int](_types_opencv__hacks_.md#int) | Rotation angle of the ellipse in degrees. See ellipse for details.  |
`arcStart` | [int](_types_opencv__hacks_.md#int) | Starting angle of the elliptic arc in degrees.  |
`arcEnd` | [int](_types_opencv__hacks_.md#int) | Ending angle of the elliptic arc in degrees.  |
`delta` | [int](_types_opencv__hacks_.md#int) | Angle between the subsequent polyline vertices. It defines the approximation accuracy.  |
`pts` | any | Output vector of polyline vertices.  |

**Returns:** *void*

___

###  fillConvexPoly

▸ **fillConvexPoly**(`img`: InputOutputArray, `pts`: any, `npts`: [int](_types_opencv__hacks_.md#int), `color`: any, `lineType?`: [int](_types_opencv__hacks_.md#int), `shift?`: [int](_types_opencv__hacks_.md#int)): *void*

*Defined in [types/opencv/imgproc_draw.ts:292](https://github.com/cancerberoSgx/mirada/blob/2aa7cf1/mirada/src/types/opencv/imgproc_draw.ts#L292)*

This is an overloaded member function, provided for convenience. It differs from the above function
only in what argument(s) it accepts.

**Parameters:**

Name | Type |
------ | ------ |
`img` | InputOutputArray |
`pts` | any |
`npts` | [int](_types_opencv__hacks_.md#int) |
`color` | any |
`lineType?` | [int](_types_opencv__hacks_.md#int) |
`shift?` | [int](_types_opencv__hacks_.md#int) |

**Returns:** *void*

▸ **fillConvexPoly**(`img`: InputOutputArray, `points`: [InputArray](_types_opencv__hacks_.md#inputarray), `color`: any, `lineType?`: [int](_types_opencv__hacks_.md#int), `shift?`: [int](_types_opencv__hacks_.md#int)): *void*

*Defined in [types/opencv/imgproc_draw.ts:310](https://github.com/cancerberoSgx/mirada/blob/2aa7cf1/mirada/src/types/opencv/imgproc_draw.ts#L310)*

The function [cv::fillConvexPoly] draws a filled convex polygon. This function is much faster than
the function [fillPoly] . It can fill not only convex polygons but any monotonic polygon without
self-intersections, that is, a polygon whose contour intersects every horizontal line (scan line)
twice at the most (though, its top-most and/or the bottom edge could be horizontal).

**Parameters:**

Name | Type | Description |
------ | ------ | ------ |
`img` | InputOutputArray | Image.  |
`points` | [InputArray](_types_opencv__hacks_.md#inputarray) | Polygon vertices.  |
`color` | any | Polygon color.  |
`lineType?` | [int](_types_opencv__hacks_.md#int) | Type of the polygon boundaries. See LineTypes  |
`shift?` | [int](_types_opencv__hacks_.md#int) | Number of fractional bits in the vertex coordinates.  |

**Returns:** *void*

___

###  fillPoly

▸ **fillPoly**(`img`: InputOutputArray, `pts`: any, `npts`: any, `ncontours`: [int](_types_opencv__hacks_.md#int), `color`: any, `lineType?`: [int](_types_opencv__hacks_.md#int), `shift?`: [int](_types_opencv__hacks_.md#int), `offset?`: [Point](../classes/_types_opencv__hacks_.point.md)): *void*

*Defined in [types/opencv/imgproc_draw.ts:316](https://github.com/cancerberoSgx/mirada/blob/2aa7cf1/mirada/src/types/opencv/imgproc_draw.ts#L316)*

This is an overloaded member function, provided for convenience. It differs from the above function
only in what argument(s) it accepts.

**Parameters:**

Name | Type |
------ | ------ |
`img` | InputOutputArray |
`pts` | any |
`npts` | any |
`ncontours` | [int](_types_opencv__hacks_.md#int) |
`color` | any |
`lineType?` | [int](_types_opencv__hacks_.md#int) |
`shift?` | [int](_types_opencv__hacks_.md#int) |
`offset?` | [Point](../classes/_types_opencv__hacks_.point.md) |

**Returns:** *void*

▸ **fillPoly**(`img`: InputOutputArray, `pts`: InputArrayOfArrays, `color`: any, `lineType?`: [int](_types_opencv__hacks_.md#int), `shift?`: [int](_types_opencv__hacks_.md#int), `offset?`: [Point](../classes/_types_opencv__hacks_.point.md)): *void*

*Defined in [types/opencv/imgproc_draw.ts:335](https://github.com/cancerberoSgx/mirada/blob/2aa7cf1/mirada/src/types/opencv/imgproc_draw.ts#L335)*

The function [cv::fillPoly] fills an area bounded by several polygonal contours. The function can
fill complex areas, for example, areas with holes, contours with self-intersections (some of their
parts), and so forth.

**Parameters:**

Name | Type | Description |
------ | ------ | ------ |
`img` | InputOutputArray | Image.  |
`pts` | InputArrayOfArrays | Array of polygons where each polygon is represented as an array of points.  |
`color` | any | Polygon color.  |
`lineType?` | [int](_types_opencv__hacks_.md#int) | Type of the polygon boundaries. See LineTypes  |
`shift?` | [int](_types_opencv__hacks_.md#int) | Number of fractional bits in the vertex coordinates.  |
`offset?` | [Point](../classes/_types_opencv__hacks_.point.md) | Optional offset of all points of the contours.  |

**Returns:** *void*

___

###  getFontScaleFromHeight

▸ **getFontScaleFromHeight**(`fontFace`: any, `pixelHeight`: any, `thickness?`: any): *[double](_types_opencv__hacks_.md#double)*

*Defined in [types/opencv/imgproc_draw.ts:348](https://github.com/cancerberoSgx/mirada/blob/2aa7cf1/mirada/src/types/opencv/imgproc_draw.ts#L348)*

The fontSize to use for [cv::putText]

[cv::putText]

**Parameters:**

Name | Type | Description |
------ | ------ | ------ |
`fontFace` | any | Font to use, see cv::HersheyFonts.  |
`pixelHeight` | any | Pixel height to compute the fontScale for  |
`thickness?` | any | Thickness of lines used to render the text.See putText for details.  |

**Returns:** *[double](_types_opencv__hacks_.md#double)*

___

###  getTextSize

▸ **getTextSize**(`text`: any, `fontFace`: [int](_types_opencv__hacks_.md#int), `fontScale`: [double](_types_opencv__hacks_.md#double), `thickness`: [int](_types_opencv__hacks_.md#int), `baseLine`: any): *[Size](../classes/_types_opencv__hacks_.size.md)*

*Defined in [types/opencv/imgproc_draw.ts:400](https://github.com/cancerberoSgx/mirada/blob/2aa7cf1/mirada/src/types/opencv/imgproc_draw.ts#L400)*

The function [cv::getTextSize] calculates and returns the size of a box that contains the specified
text. That is, the following code renders some text, the tight box surrounding it, and the baseline:
:

```cpp
String text = "Funny text inside the box";
int fontFace = FONT_HERSHEY_SCRIPT_SIMPLEX;
double fontScale = 2;
int thickness = 3;

Mat img(600, 800, CV_8UC3, Scalar::all(0));

int baseline=0;
Size textSize = getTextSize(text, fontFace,
                            fontScale, thickness, &baseline);
baseline += thickness;

// center the text
Point textOrg((img.cols - textSize.width)/2,
              (img.rows + textSize.height)/2);

// draw the box
rectangle(img, textOrg + Point(0, baseline),
          textOrg + Point(textSize.width, -textSize.height),
          Scalar(0,0,255));
// ... and the baseline first
line(img, textOrg + Point(0, thickness),
     textOrg + Point(textSize.width, thickness),
     Scalar(0, 0, 255));

// then put the text itself
putText(img, text, textOrg, fontFace, fontScale,
        Scalar::all(255), thickness, 8);
```

The size of a box that contains the specified text.

[putText]

**Parameters:**

Name | Type | Description |
------ | ------ | ------ |
`text` | any | Input text string.  |
`fontFace` | [int](_types_opencv__hacks_.md#int) | Font to use, see HersheyFonts.  |
`fontScale` | [double](_types_opencv__hacks_.md#double) | Font scale factor that is multiplied by the font-specific base size.  |
`thickness` | [int](_types_opencv__hacks_.md#int) | Thickness of lines used to render the text. See putText for details.  |
`baseLine` | any | y-coordinate of the baseline relative to the bottom-most text point.  |

**Returns:** *[Size](../classes/_types_opencv__hacks_.size.md)*

___

###  line

▸ **line**(`img`: InputOutputArray, `pt1`: [Point](../classes/_types_opencv__hacks_.point.md), `pt2`: [Point](../classes/_types_opencv__hacks_.point.md), `color`: any, `thickness?`: [int](_types_opencv__hacks_.md#int), `lineType?`: [int](_types_opencv__hacks_.md#int), `shift?`: [int](_types_opencv__hacks_.md#int)): *void*

*Defined in [types/opencv/imgproc_draw.ts:422](https://github.com/cancerberoSgx/mirada/blob/2aa7cf1/mirada/src/types/opencv/imgproc_draw.ts#L422)*

The function line draws the line segment between pt1 and pt2 points in the image. The line is
clipped by the image boundaries. For non-antialiased lines with integer coordinates, the 8-connected
or 4-connected Bresenham algorithm is used. Thick lines are drawn with rounding endings. Antialiased
lines are drawn using Gaussian filtering.

**Parameters:**

Name | Type | Description |
------ | ------ | ------ |
`img` | InputOutputArray | Image.  |
`pt1` | [Point](../classes/_types_opencv__hacks_.point.md) | First point of the line segment.  |
`pt2` | [Point](../classes/_types_opencv__hacks_.point.md) | Second point of the line segment.  |
`color` | any | Line color.  |
`thickness?` | [int](_types_opencv__hacks_.md#int) | Line thickness.  |
`lineType?` | [int](_types_opencv__hacks_.md#int) | Type of the line. See LineTypes.  |
`shift?` | [int](_types_opencv__hacks_.md#int) | Number of fractional bits in the point coordinates.  |

**Returns:** *void*

___

###  polylines

▸ **polylines**(`img`: InputOutputArray, `pts`: any, `npts`: any, `ncontours`: [int](_types_opencv__hacks_.md#int), `isClosed`: [bool](_types_opencv__hacks_.md#bool), `color`: any, `thickness?`: [int](_types_opencv__hacks_.md#int), `lineType?`: [int](_types_opencv__hacks_.md#int), `shift?`: [int](_types_opencv__hacks_.md#int)): *void*

*Defined in [types/opencv/imgproc_draw.ts:428](https://github.com/cancerberoSgx/mirada/blob/2aa7cf1/mirada/src/types/opencv/imgproc_draw.ts#L428)*

This is an overloaded member function, provided for convenience. It differs from the above function
only in what argument(s) it accepts.

**Parameters:**

Name | Type |
------ | ------ |
`img` | InputOutputArray |
`pts` | any |
`npts` | any |
`ncontours` | [int](_types_opencv__hacks_.md#int) |
`isClosed` | [bool](_types_opencv__hacks_.md#bool) |
`color` | any |
`thickness?` | [int](_types_opencv__hacks_.md#int) |
`lineType?` | [int](_types_opencv__hacks_.md#int) |
`shift?` | [int](_types_opencv__hacks_.md#int) |

**Returns:** *void*

▸ **polylines**(`img`: InputOutputArray, `pts`: InputArrayOfArrays, `isClosed`: [bool](_types_opencv__hacks_.md#bool), `color`: any, `thickness?`: [int](_types_opencv__hacks_.md#int), `lineType?`: [int](_types_opencv__hacks_.md#int), `shift?`: [int](_types_opencv__hacks_.md#int)): *void*

*Defined in [types/opencv/imgproc_draw.ts:448](https://github.com/cancerberoSgx/mirada/blob/2aa7cf1/mirada/src/types/opencv/imgproc_draw.ts#L448)*

The function [cv::polylines] draws one or more polygonal curves.

**Parameters:**

Name | Type | Description |
------ | ------ | ------ |
`img` | InputOutputArray | Image.  |
`pts` | InputArrayOfArrays | Array of polygonal curves.  |
`isClosed` | [bool](_types_opencv__hacks_.md#bool) | Flag indicating whether the drawn polylines are closed or not. If they are closed, the function draws a line from the last vertex of each curve to its first vertex.  |
`color` | any | Polyline color.  |
`thickness?` | [int](_types_opencv__hacks_.md#int) | Thickness of the polyline edges.  |
`lineType?` | [int](_types_opencv__hacks_.md#int) | Type of the line segments. See LineTypes  |
`shift?` | [int](_types_opencv__hacks_.md#int) | Number of fractional bits in the vertex coordinates.  |

**Returns:** *void*

___

###  putText

▸ **putText**(`img`: InputOutputArray, `text`: any, `org`: [Point](../classes/_types_opencv__hacks_.point.md), `fontFace`: [int](_types_opencv__hacks_.md#int), `fontScale`: [double](_types_opencv__hacks_.md#double), `color`: [Scalar](../classes/_types_opencv__hacks_.scalar.md), `thickness?`: [int](_types_opencv__hacks_.md#int), `lineType?`: [int](_types_opencv__hacks_.md#int), `bottomLeftOrigin?`: [bool](_types_opencv__hacks_.md#bool)): *void*

*Defined in [types/opencv/imgproc_draw.ts:474](https://github.com/cancerberoSgx/mirada/blob/2aa7cf1/mirada/src/types/opencv/imgproc_draw.ts#L474)*

The function [cv::putText] renders the specified text string in the image. Symbols that cannot be
rendered using the specified font are replaced by question marks. See [getTextSize] for a text
rendering code example.

**Parameters:**

Name | Type | Description |
------ | ------ | ------ |
`img` | InputOutputArray | Image.  |
`text` | any | Text string to be drawn.  |
`org` | [Point](../classes/_types_opencv__hacks_.point.md) | Bottom-left corner of the text string in the image.  |
`fontFace` | [int](_types_opencv__hacks_.md#int) | Font type, see HersheyFonts.  |
`fontScale` | [double](_types_opencv__hacks_.md#double) | Font scale factor that is multiplied by the font-specific base size.  |
`color` | [Scalar](../classes/_types_opencv__hacks_.scalar.md) | Text color.  |
`thickness?` | [int](_types_opencv__hacks_.md#int) | Thickness of the lines used to draw a text.  |
`lineType?` | [int](_types_opencv__hacks_.md#int) | Line type. See LineTypes  |
`bottomLeftOrigin?` | [bool](_types_opencv__hacks_.md#bool) | When true, the image data origin is at the bottom-left corner. Otherwise, it is at the top-left corner.  |

**Returns:** *void*

___

###  rectangle

▸ **rectangle**(`img`: InputOutputArray, `pt1`: [Point](../classes/_types_opencv__hacks_.point.md), `pt2`: [Point](../classes/_types_opencv__hacks_.point.md), `color`: any, `thickness?`: [int](_types_opencv__hacks_.md#int), `lineType?`: [int](_types_opencv__hacks_.md#int), `shift?`: [int](_types_opencv__hacks_.md#int)): *void*

*Defined in [types/opencv/imgproc_draw.ts:495](https://github.com/cancerberoSgx/mirada/blob/2aa7cf1/mirada/src/types/opencv/imgproc_draw.ts#L495)*

The function [cv::rectangle] draws a rectangle outline or a filled rectangle whose two opposite
corners are pt1 and pt2.

**Parameters:**

Name | Type | Description |
------ | ------ | ------ |
`img` | InputOutputArray | Image.  |
`pt1` | [Point](../classes/_types_opencv__hacks_.point.md) | Vertex of the rectangle.  |
`pt2` | [Point](../classes/_types_opencv__hacks_.point.md) | Vertex of the rectangle opposite to pt1 .  |
`color` | any | Rectangle color or brightness (grayscale image).  |
`thickness?` | [int](_types_opencv__hacks_.md#int) | Thickness of lines that make up the rectangle. Negative values, like FILLED, mean that the function has to draw a filled rectangle.  |
`lineType?` | [int](_types_opencv__hacks_.md#int) | Type of the line. See LineTypes  |
`shift?` | [int](_types_opencv__hacks_.md#int) | Number of fractional bits in the point coordinates.  |

**Returns:** *void*

▸ **rectangle**(`img`: InputOutputArray, `rec`: [Rect](../classes/_types_opencv__hacks_.rect.md), `color`: any, `thickness?`: [int](_types_opencv__hacks_.md#int), `lineType?`: [int](_types_opencv__hacks_.md#int), `shift?`: [int](_types_opencv__hacks_.md#int)): *void*

*Defined in [types/opencv/imgproc_draw.ts:504](https://github.com/cancerberoSgx/mirada/blob/2aa7cf1/mirada/src/types/opencv/imgproc_draw.ts#L504)*

This is an overloaded member function, provided for convenience. It differs from the above function
only in what argument(s) it accepts.

use `rec` parameter as alternative specification of the drawn rectangle: `r.tl() and
r.br()-Point(1,1)` are opposite corners

**Parameters:**

Name | Type |
------ | ------ |
`img` | InputOutputArray |
`rec` | [Rect](../classes/_types_opencv__hacks_.rect.md) |
`color` | any |
`thickness?` | [int](_types_opencv__hacks_.md#int) |
`lineType?` | [int](_types_opencv__hacks_.md#int) |
`shift?` | [int](_types_opencv__hacks_.md#int) |

**Returns:** *void*